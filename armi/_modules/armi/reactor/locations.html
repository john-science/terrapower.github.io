

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>armi.reactor.locations &mdash; ARMI 0.1.4 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_fixes.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/armiicon_16x16.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #233C5B" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> ARMI
          

          
            
            <img src="../../../_static/armiicon_24x24.ico" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user/index.html">User Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/index.html">Developer Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../blog/index.html">News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../.apidocs/modules.html">API Docs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARMI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../armi.html">armi</a> &raquo;</li>
        
          <li><a href="../reactor.html">armi.reactor</a> &raquo;</li>
        
      <li>armi.reactor.locations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for armi.reactor.locations</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2019 TerraPower, LLC</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The location module is responsible for identifying the spatial position of objects in the reactor model.</span>

<span class="sd">It also contains code useful for traversing regular meshes (hexagons, etc.).</span>

<span class="sd">.. warning:: The code in this module is deprecated in favor of the Grid and</span>
<span class="sd">             SpatialLocator classes defined in ``grids.py``. New code should not be</span>
<span class="sd">             implemented against these classes.</span>

<span class="sd">The Location Object</span>
<span class="sd">-------------------</span>
<span class="sd">Each ARMI Block (and Assembly) contains a Location object whose purpose it is to identify</span>
<span class="sd">where in the core the structure resides. Location objects are represented as strings when</span>
<span class="sd">printed or written because their original primary usage was to be written directly to</span>
<span class="sd">textual neutronics input files, but they contain much more functionality. An assembly</span>
<span class="sd">location in ARMI is based on the DIF3D region definition and has a somewhat strange</span>
<span class="sd">representation for this reason. The coordinate system is counterclockwise spiral, as seen</span>
<span class="sd">in the figure below.</span>

<span class="sd">.. image:: /.static/coreMap.png</span>
<span class="sd">       :width: 100%</span>

<span class="sd">Here are some examples of using a Location object::</span>

<span class="sd">    loc =  a.getLocationObject()</span>
<span class="sd">    ring, pos = loc.mainIndices()</span>
<span class="sd">    x,y = loc.coords(p=assemPitch)</span>
<span class="sd">    locStr = a.getLocation() # the string representation of a location object</span>


<span class="sd">ThetaRZ Location Objects</span>
<span class="sd">------------------------</span>
<span class="sd">ARMI can use theta-r-z objects to help it understand cylindrical systems -- as</span>
<span class="sd">opposed to hexagonal systems. However, the radial segment discretizations of a</span>
<span class="sd">cylindrical mesh are less structured than a hexagonal array. Therefore, to</span>
<span class="sd">these ThetaRZ location objects use a mesh object to translate integer</span>
<span class="sd">coordinates to spatial dimensions. Location objects as implemented</span>
<span class="sd">are best suited for structured grids (e.g. triangular, hexagonal, Cartesian).</span>

<span class="sd">.. note:: Theta-RZ is used instead of the more common RZ-Theta because the DIF3D code</span>
<span class="sd">          uses this convention. In turn, DIF3D uses this convention to allow the same</span>
<span class="sd">          numerical solver algorithms to solve all geometry options consistently.</span>
<span class="sd">          The numerical methods for X and Y plane solutions are analogous to</span>
<span class="sd">          the 2-D theta-R planes, and Z in the final position is consistent between</span>
<span class="sd">          XYZ, Triangular-Z, Hex-Z, and TRZ solvers.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">armi.runLog</span> <span class="k">as</span> <span class="nn">runLog</span>
<span class="kn">from</span> <span class="nn">armi</span> <span class="k">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">armi.utils</span> <span class="k">import</span> <span class="n">hexagon</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="k">import</span> <span class="n">geometry</span>


<span class="n">COS30</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="n">SIN30</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="kn">from</span> <span class="nn">armi.reactor.grids</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">BOUNDARY_0_DEGREES</span><span class="p">,</span>
    <span class="n">BOUNDARY_60_DEGREES</span><span class="p">,</span>
    <span class="n">BOUNDARY_120_DEGREES</span><span class="p">,</span>
    <span class="n">BOUNDARY_CENTER</span><span class="p">,</span>
    <span class="n">AXIAL_CHARS</span><span class="p">,</span>
    <span class="n">ASCII_LETTER_A</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">armi.reactor</span> <span class="k">import</span> <span class="n">grids</span>


<div class="viewcode-block" id="dotProduct"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.dotProduct">[docs]</a><span class="k">def</span> <span class="nf">dotProduct</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the dot product of two vectors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v1, v2 : tuple</span>
<span class="sd">        Vector represented as an n dimensional tuple</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The dot product of two vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span></div>


<div class="viewcode-block" id="vectorLength"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.vectorLength">[docs]</a><span class="k">def</span> <span class="nf">vectorLength</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the length of a vector</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v1, v2 : tuple</span>
<span class="sd">        Vector represented as an n dimensional tuple</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dotProduct</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span></div>


<div class="viewcode-block" id="angleBetweenVectors"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.angleBetweenVectors">[docs]</a><span class="k">def</span> <span class="nf">angleBetweenVectors</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the angle between two vectors in radians.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v1, v2 : tuple</span>
<span class="sd">        Vector represented as an n dimensional tuple</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v2Size</span> <span class="o">=</span> <span class="n">vectorLength</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">v2Size</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">dotProduct</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">/</span> <span class="n">v2Size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">theta</span></div>


<div class="viewcode-block" id="Location"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location">[docs]</a><span class="k">class</span> <span class="nc">Location</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract Location object used a as a base class for other concrete definitions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">i2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate a new Location object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i1 : int, optional</span>
<span class="sd">            1st coordinate index in core 2d map (ring number in hexes)</span>

<span class="sd">        i2 : int, optional</span>
<span class="sd">            2nd coordinate in core map (ring position in hex)</span>

<span class="sd">        axial : str, or int optional</span>
<span class="sd">            a letter representing axial slab (&#39;A&#39;, &#39;B&#39;, etc.). If no axial is given,</span>
<span class="sd">            this is a 2D (radial) location</span>

<span class="sd">        label : str, optional</span>
<span class="sd">            A label for this location, e.g. &#39;ExCore&#39;, &#39;SFP&#39;. If in Location-label format,</span>
<span class="sd">            i1, i2, and axial will be inherited from it. Otherwise, the location</span>
<span class="sd">            will be considered Ex-core</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">=</span> <span class="n">i1</span>  <span class="c1"># will be 1 for center.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">=</span> <span class="n">i2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setAxial</span><span class="p">(</span><span class="n">axial</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;ExCore&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">makeLabel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fromLabel</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firstChar</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Location.__eq__"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check equality between locations.</span>

<span class="sd">        .. warning:: Because a Location object is mutable, this is NOT guaranteed to be consistent</span>
<span class="sd">                     for the same two objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Location</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">considerations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">i1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">i2</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">axial</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">considerations</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Location.__lt__"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.__lt__">[docs]</a>    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare two locations in a less-than sense. This allows sorting.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">i1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">i1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">i1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">i2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">i2</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">axial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">axial</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Location.__gt__"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.__gt__">[docs]</a>    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare two locations in a greater-than sense.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">i1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">i1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">i2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">i2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">axial</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Location.setAxial"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.setAxial">[docs]</a>    <span class="k">def</span> <span class="nf">setAxial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axialIndexOrChar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Axial index used to be a letter A_Z but is now a number 0 through N.</span>

<span class="sd">        When axial index has to be represented as a single character (e.g. in some global flux solvers),</span>
<span class="sd">        ASCII characters listed in ``locations.AXIAL_CHARS`` are valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axialIndexOrChar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axial</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axialIndexOrChar</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">axial</span> <span class="o">=</span> <span class="n">axialIndexOrChar</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axialIndexOrChar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># convert A to 0, B to 1, etc.</span>
            <span class="n">axial</span> <span class="o">=</span> <span class="n">AXIAL_CHARS</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axialIndexOrChar</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid location axial setting </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axialIndexOrChar</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">axial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">axial</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axial</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">AXIAL_CHARS</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many or too few axial nodes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axial</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">=</span> <span class="n">axial</span></div>

<div class="viewcode-block" id="Location.__repr__"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represent the location object as a string.</span>

<span class="sd">        An example Location is represented as A5002B. The first two digits represent the ring. A5 is actually</span>
<span class="sd">        ring 05. A7 is 07. B3 is 13. The final digit represents the axial location, starting with A at the</span>
<span class="sd">        bottom. The representation starts with a letter because DIF3D doesn&#39;t allow region labels to start</span>
<span class="sd">        with a numeric character, and the original purpose of Location was to be written directly to DIF3D inputs.</span>
<span class="sd">        But you don&#39;t have to convert the name to get the ring number. Just use</span>
<span class="sd">        the Location.mainIndices method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeLabel</span><span class="p">()</span>  <span class="c1"># update the label in case it&#39;s changed.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span></div>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">spec</span><span class="p">)</span>

<div class="viewcode-block" id="Location.duplicate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.duplicate">[docs]</a>    <span class="k">def</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span><span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="Location.setIndexNames"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.setIndexNames">[docs]</a>    <span class="k">def</span> <span class="nf">setIndexNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Location.isInCore"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.isInCore">[docs]</a>    <span class="k">def</span> <span class="nf">isInCore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Location.makeLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.makeLabel">[docs]</a>    <span class="k">def</span> <span class="nf">makeLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a label based on the location. Something in ring 3, position 10, axial slab 3 will</span>
<span class="sd">        get A3010C</span>

<span class="sd">        The original purpose of these labels to name DIF3D regions</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setIndexNames</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isInCore</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getFirstChar</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># stick with what we have. (default:ExCore)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstChar</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{0:03d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># add axial letter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="n">AXIAL_CHARS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axial</span><span class="p">]</span></div>

<div class="viewcode-block" id="Location.setLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.setLabel">[docs]</a>    <span class="k">def</span> <span class="nf">setLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">desc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allows for special labels like &quot;discharged&quot; or &quot;fresh&quot;. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">desc</span></div>

<div class="viewcode-block" id="Location.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Location.isInSameStackAs"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.isInSameStackAs">[docs]</a>    <span class="k">def</span> <span class="nf">isInSameStackAs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines if another location is stacked with this one (for equivalence testing).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">==</span> <span class="n">loc</span><span class="o">.</span><span class="n">i1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">==</span> <span class="n">loc</span><span class="o">.</span><span class="n">i2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Location.uniqueInt"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.uniqueInt">[docs]</a>    <span class="k">def</span> <span class="nf">uniqueInt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a unique integer based on the location. Good for adding to SQL databases.&quot;&quot;&quot;</span>
        <span class="c1"># handle empty locations too</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="ow">or</span> <span class="mi">0</span>  <span class="c1"># converts None to 0</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="n">axial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">100000</span> <span class="o">*</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">axial</span></div>

<div class="viewcode-block" id="Location.fromUniqueInt"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.fromUniqueInt">[docs]</a>    <span class="k">def</span> <span class="nf">fromUniqueInt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uniqInt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a location based on the unique int generated above.</span>
<span class="sd">        </span>
<span class="sd">        ring 30, position 174, axial B would be 3017466.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Limits: No more than 999 positions, 99 axial positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uniqInt</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unique int </span><span class="si">{}</span><span class="s2"> of type </span><span class="si">{}</span><span class="s2"> was not an integer&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">uniqInt</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">uniqInt</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">uniqInt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unique int </span><span class="si">{}</span><span class="s2"> was negative&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uniqInt</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">uniqInt</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">8</span><span class="p">:</span>  <span class="c1"># 3 ints for i1, 3 for i2 and 2 for axial</span>
            <span class="c1"># while 999 rings is not possible with only 999 positions, other geometries (eg Cartesian) might need 999</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unique int </span><span class="si">{}</span><span class="s2"> was larger than expected. &quot;</span>
                <span class="s2">&quot;This likely indicates more than 999 positions in the i1 (ring in hex) dimension&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">uniqInt</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:09d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uniqInt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># or None # everything else is ring</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># or None  # the next three from the right are position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>  <span class="c1"># grab the last two letters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">makeLabel</span><span class="p">()</span></div>

<div class="viewcode-block" id="Location.fromLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.fromLabel">[docs]</a>    <span class="k">def</span> <span class="nf">fromLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set location parameters from a string label.</span>

<span class="sd">        given a label like A2034B, create a location. This allows the reverse of makeLabel to occur.</span>
<span class="sd">        Given a region name in REBUS, this can figure out where in the core it is. That&#39;s assuming</span>
<span class="sd">        someone set up the REBUS file according to our standards, of course.</span>

<span class="sd">        A &quot;location label&quot; is in the format 11222A where 11 represents the i1 index,</span>
<span class="sd">        222 represents the i2 index, and A represents the axial signifier.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : str</span>
<span class="sd">            The label to process.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; loc.fromLabel(&#39;A2024&#39;)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        makeLabel : does the opposite</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">ringPosFromRingLabel</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># arbitrary label. excore.</span>
            <span class="c1"># set it up as if it&#39;s a freshly initialized one</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">getFirstChar</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeLabel</span><span class="p">()</span></div>

<div class="viewcode-block" id="Location.getFirstChar"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.getFirstChar">[docs]</a>    <span class="k">def</span> <span class="nf">getFirstChar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a ring number into a character since REBUS can&#39;t handle region names</span>
<span class="sd">        that start with numbers.</span>

<span class="sd">        1 - 9  -&gt; A</span>
<span class="sd">        10- 19 -&gt; B</span>
<span class="sd">        20- 29 -&gt; C, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">firstChar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chrNum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chrNum</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">:</span>
                <span class="c1"># should result in something like A4 for 4, B6 for 16</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">firstChar</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">ASCII_LETTER_A</span> <span class="o">+</span> <span class="n">chrNum</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;invalid location. ring </span><span class="si">{0}</span><span class="s2"> is too many rings!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="p">,</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Location.mainIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.mainIndices">[docs]</a>    <span class="k">def</span> <span class="nf">mainIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns the standard (i1, i2) = (ring, pos) hex indices.</span>
<span class="sd">        ring and pos begin with 1 (not 0).</span>
<span class="sd">        Note how this is different than HexLocation.indices, which returns MCNP GEODST indices.</span>

<span class="sd">        Note that (i, j) refers to (ring, pos) in fluxRecon.py, while (i, j) refers to the MCNP</span>
<span class="sd">        GEODST (grid-like) indices in locations.py. Sorry for any confusion!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.i1, self.i2 : int pair</span>
<span class="sd">            The value of (i2, i2) = (ring, pos) for the HexLocation object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; loc.mainIndices()</span>
<span class="sd">        (4, 5)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        locations.HexLocation.indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span></div>

<div class="viewcode-block" id="Location.fromIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.fromIndices">[docs]</a>    <span class="k">def</span> <span class="nf">fromIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i1</span> <span class="o">=</span> <span class="n">i1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">=</span> <span class="n">i2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeLabel</span><span class="p">()</span></div>

<div class="viewcode-block" id="Location.getDistanceOfLocationToPoint"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.getDistanceOfLocationToPoint">[docs]</a>    <span class="k">def</span> <span class="nf">getDistanceOfLocationToPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetCoords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pitch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the distance between the current coordinates and the targetCoords.</span>

<span class="sd">        This is used to help determine the optimal packing for a core</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        targetCoords : tuple or HexLocation</span>
<span class="sd">            the x, y coordinates that will be compared to current coords of this location</span>

<span class="sd">        pitch : float</span>
<span class="sd">            the pitch of the assemblies</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># auto detect what the input is for auto coords and translate into a tuple</span>
        <span class="k">if</span> <span class="n">targetCoords</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targetCoords</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">targetCoords</span> <span class="o">=</span> <span class="n">targetCoords</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">pitch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">targetCoords</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">currentCoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="n">currentCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetCoords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">currentCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">targetCoords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Location.getAngle"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.getAngle">[docs]</a>    <span class="k">def</span> <span class="nf">getAngle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">targetPoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pointOfVectorIntersection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pitch</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the angle of this location compared to a targetPoint using a vector intersection point.</span>

<span class="sd">        The location object coordinates and targetPoint are used with the pointOfVectorIntersection to produce</span>
<span class="sd">        vectors.  Using these vectors, the angle between them can be calculated</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        targetPoint : tuple, location object</span>
<span class="sd">            A tuple of the x, y coordinates to be compared with</span>

<span class="sd">        pointOfVectorIntersection : tuple, location object</span>
<span class="sd">            A tuple of the x, y coordinates to be compared with</span>

<span class="sd">        degrees : bool, optional</span>
<span class="sd">            If true, return degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">targetPoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">targetPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pointOfVectorIntersection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pointOfVectorIntersection</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># auto detect what the input is for auto coords and translate into a tuple</span>
        <span class="k">if</span> <span class="n">targetPoint</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targetPoint</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">targetPoint</span> <span class="o">=</span> <span class="n">targetPoint</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">pitch</span><span class="p">)</span>  <span class="c1"># pylint:disable=no-member</span>

        <span class="c1"># auto detect what the input is for auto coords and translate into a tuple</span>
        <span class="k">if</span> <span class="n">pointOfVectorIntersection</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">pointOfVectorIntersection</span><span class="p">,</span> <span class="nb">tuple</span>
        <span class="p">):</span>
            <span class="n">pointOfVectorIntersection</span> <span class="o">=</span> <span class="n">pointOfVectorIntersection</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span>
                <span class="n">p</span><span class="o">=</span><span class="n">pitch</span>
            <span class="p">)</span>  <span class="c1"># pylint:disable=no-member</span>

        <span class="n">referenceVector</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">targetPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pointOfVectorIntersection</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">targetPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pointOfVectorIntersection</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">locationVector</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">pitch</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pointOfVectorIntersection</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">pitch</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pointOfVectorIntersection</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">angleBetweenVectors</span><span class="p">(</span><span class="n">referenceVector</span><span class="p">,</span> <span class="n">locationVector</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">locationVector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">theta</span>
        <span class="k">if</span> <span class="n">degrees</span><span class="p">:</span>
            <span class="n">theta</span> <span class="o">*=</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">return</span> <span class="n">theta</span></div>

<div class="viewcode-block" id="Location.isOnWhichSymmetryLine"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.isOnWhichSymmetryLine">[docs]</a>    <span class="k">def</span> <span class="nf">isOnWhichSymmetryLine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return flag for which symmetry line this location is on.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.locations.HexLocation.isOnWhichSymmetryLine</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Location.indices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.indices">[docs]</a>    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span></div>

<div class="viewcode-block" id="Location.fromLocator"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Location.fromLocator">[docs]</a>    <span class="k">def</span> <span class="nf">fromLocator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeLabel</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="HexLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation">[docs]</a><span class="k">class</span> <span class="nc">HexLocation</span><span class="p">(</span><span class="n">Location</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Single location in a regular hexagonal mesh.</span>

<span class="sd">    This is mutable. It represents a single location at a given time but any instance</span>
<span class="sd">    can be changed to represent any location.</span>

<span class="sd">    For this reason, whenever storing data for a single location, a tuple (i1, i2, ...)</span>
<span class="sd">    should be used instead of the location object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="HexLocation.setIndexNames"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.setIndexNames">[docs]</a>    <span class="k">def</span> <span class="nf">setIndexNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span></div>

<div class="viewcode-block" id="HexLocation.niceLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.niceLabel">[docs]</a>    <span class="k">def</span> <span class="nf">niceLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isInCore</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;Ring,Pos= </span><span class="si">{0:3d}</span><span class="s2"> </span><span class="si">{1:3d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span></div>

<div class="viewcode-block" id="HexLocation.fromLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.fromLabel">[docs]</a>    <span class="k">def</span> <span class="nf">fromLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="n">Location</span><span class="o">.</span><span class="n">fromLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span></div>

<div class="viewcode-block" id="HexLocation.isOnWhichSymmetryLine"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.isOnWhichSymmetryLine">[docs]</a>    <span class="k">def</span> <span class="nf">isOnWhichSymmetryLine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of what lines of symmetry this is on. If none, returns []</span>
<span class="sd">        If on a line of symmetry in 1/6 geometry, returns a list containing a 6.</span>
<span class="sd">        If on a line of symmetry in 1/3 geometry, returns a list containing a 3.</span>
<span class="sd">        It seems that only the 1/3 core view geometry is actually coded in here right now.</span>

<span class="sd">        Ring  Edge1 Edge2 Edge3</span>
<span class="sd">        1       1     1     1</span>
<span class="sd">        3       12    2     4</span>
<span class="sd">        5       23    3     7</span>
<span class="sd">        7       34    4    10</span>
<span class="sd">        9       45    5    13</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># only odd numbered rings can cut lines of symmetry</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">symmetryLine</span> <span class="o">=</span> <span class="n">BOUNDARY_CENTER</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">-</span> <span class="p">((</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="c1"># edge 1: 1/3 symmetry line (bottom horizontal side in 1/3 core view, theta = 0)</span>
                <span class="n">symmetryLine</span> <span class="o">=</span> <span class="n">BOUNDARY_0_DEGREES</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># edge 2: 1/6 symmetry line (bisects 1/3 core view, theta = pi/3)</span>
                <span class="n">symmetryLine</span> <span class="o">=</span> <span class="n">BOUNDARY_60_DEGREES</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># edge 3: 1/3 symmetry line (left oblique side in 1/3 core view, theta = 2*pi/3)</span>
                <span class="n">symmetryLine</span> <span class="o">=</span> <span class="n">BOUNDARY_120_DEGREES</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">symmetryLine</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">return</span> <span class="n">symmetryLine</span></div>

<div class="viewcode-block" id="HexLocation.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Figures out x, y coordinates of this location given a hex pitch p.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># useful for doing relative distance comparisons.</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">COS30</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">SIN30</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rotationDegreesCCW</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">rotateXY</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>

<div class="viewcode-block" id="HexLocation.indicesAndEdge"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.indicesAndEdge">[docs]</a>    <span class="k">def</span> <span class="nf">indicesAndEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the i, j 0-based indices of a location in a grid as well as the edge.</span>

<span class="sd">        Like, for instance, in an MCNP repeated geometry grid...</span>

<span class="sd">        These are called MCNP GEODST coordinates.</span>
<span class="sd">        They look like oblique (angled or bent) x-y coordinates.</span>

<span class="sd">        From the MCNP5 Manual, VOL2: Figure 4-26, pg. 4-36 or so</span>

<span class="sd">        So, ring 5, pos 1 becomes (4, 0).</span>
<span class="sd">        Ring 6, pos 2 becomes (4, 1)</span>
<span class="sd">        Ring 3, pos 12 becomes (2, -1)</span>
<span class="sd">        etc.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is being replaced by utils.grids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="c1">## Edge indicates which edge of the ring in which the hexagon resides.</span>
        <span class="c1">## Edge 0 is the NW edge, edge 1 is the N edge, etc.</span>
        <span class="c1">## Offset is (0-based) index of the hexagon in that edge. For instance,</span>
        <span class="c1">## ring 3, pos 12 resides in edge 5 at index 1; it is the second hexagon</span>
        <span class="c1">## in ring 3, edge 5.</span>
        <span class="n">edge</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>  <span class="c1"># = pos//ring, pos%ring</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">-</span> <span class="n">offset</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">ring</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">ring</span>
            <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span> <span class="o">+</span> <span class="n">ring</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="n">ring</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="n">ring</span>
        <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">ring</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">ring</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Edge </span><span class="si">{}</span><span class="s2"> is invalid. From ring </span><span class="si">{}</span><span class="s2">, pos </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">edge</span></div>

<div class="viewcode-block" id="HexLocation.indices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.indices">[docs]</a>    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the i, j indices of a location in a grid&quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicesAndEdge</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span></div>

<div class="viewcode-block" id="HexLocation.getSymmetricIdenticalsThird"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.getSymmetricIdenticalsThird">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetricIdenticalsThird</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">locClass</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the locations that are symmetric to this one in 1/3 geometry</span>

<span class="sd">        The number of positions :math:`N_i` in hex ring :math:`i` is</span>

<span class="sd">        .. math::</span>

<span class="sd">            N_i=</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">             1              &amp; \text{if }  i = 0 \\</span>
<span class="sd">             6 \times (i-1) &amp;  \text{if } i &gt; 0</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        There are :math:`\frac{N_i}{3}` positions between one position and</span>
<span class="sd">        its 1/3-symmetric position. The symmetric identical are</span>
<span class="sd">        computed accordingly.</span>

<span class="sd">        .. NOTE:: If a position is computed that is greater than</span>
<span class="sd">             the maximum number of positions in a ring, the roll-over</span>
<span class="sd">             is computed by subtracting the maximum number of positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ring : int, optional</span>
<span class="sd">            ring number. Defaults to this location&#39;s ring number</span>
<span class="sd">        pos : int, optional</span>
<span class="sd">            position in ring, defaults to this location&#39;s position number</span>
<span class="sd">        locClass : Location object, optional</span>
<span class="sd">            The location object to instantiate. Defaults to HexLocation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        otherAssems :  2 other locations that are identical in 1/3 -symmetry</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">locClass</span><span class="p">:</span>
            <span class="n">locClass</span> <span class="o">=</span> <span class="n">HexLocation</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># nothing symmetric in the center.</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">HexGrid</span><span class="o">.</span><span class="n">fromPitch</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">THIRD_CORE</span> <span class="o">+</span> <span class="n">geometry</span><span class="o">.</span><span class="n">PERIODIC</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getIndicesFromRingAndPos</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">identicalsIJ</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getSymmetricEquivalents</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ij</span> <span class="ow">in</span> <span class="n">identicalsIJ</span><span class="p">:</span>
            <span class="n">ring</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getRingPos</span><span class="p">(</span><span class="n">ij</span><span class="p">)</span>
            <span class="n">locs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locClass</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">locs</span></div>

<div class="viewcode-block" id="HexLocation.getSymmetricIdenticalsSixth"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.getSymmetricIdenticalsSixth">[docs]</a>    <span class="k">def</span> <span class="nf">getSymmetricIdenticalsSixth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locClass</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns locations that are identical in 1/6 -symmetry&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">locClass</span><span class="p">:</span>
            <span class="n">locClass</span> <span class="o">=</span> <span class="n">HexLocation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># nothing symmetric in the center.</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">numInRing</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">for</span> <span class="n">others_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">numInRing</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="n">numInRing</span>
            <span class="n">locs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locClass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ring</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">locs</span></div>

<div class="viewcode-block" id="HexLocation.getNumPositions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.getNumPositions">[docs]</a>    <span class="k">def</span> <span class="nf">getNumPositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return The total number of positions in the specified number of rings.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        a single pin counts as 1 ring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span>

        <span class="k">if</span> <span class="n">rings</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">6</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rings</span><span class="p">)])</span></div>

<div class="viewcode-block" id="HexLocation.getNumPosInRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.getNumPosInRing">[docs]</a>    <span class="k">def</span> <span class="nf">getNumPosInRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of positions in a ring.&quot;&quot;&quot;</span>
        <span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ring</span>
        <span class="k">return</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numPositionsInRing</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexLocation.getNumRings"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.getNumRings">[docs]</a>    <span class="k">def</span> <span class="nf">getNumRings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nPins</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of rings required to hold a specific number of items, rounding up.&quot;&quot;&quot;</span>
        <span class="n">nRings</span> <span class="o">=</span> <span class="n">hexagon</span><span class="o">.</span><span class="n">numRingsToHoldNumCells</span><span class="p">(</span><span class="n">nPins</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
            <span class="n">nPinsFullRings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPositions</span><span class="p">(</span><span class="n">rings</span><span class="o">=</span><span class="n">nRings</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nPins</span> <span class="o">!=</span> <span class="n">nPinsFullRings</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> does not fit exactly into a hex grid of any number of rings. &quot;</span>
                    <span class="s2">&quot;Rounding up to </span><span class="si">{1}</span><span class="s2"> rings which can hold </span><span class="si">{2}</span><span class="s2"> pins)&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nPins</span><span class="p">,</span> <span class="n">nRings</span><span class="p">,</span> <span class="n">nPinsFullRings</span><span class="p">),</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Non-exact number of positions in hex lattice&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">nRings</span></div>

<div class="viewcode-block" id="HexLocation.getNumPinsInLine"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.getNumPinsInLine">[docs]</a>    <span class="k">def</span> <span class="nf">getNumPinsInLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return how many pins in a line fit in the center of a hex w/ this many rings.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Cannot determine number of pins in a hex &quot;</span>
                        <span class="s2">&quot;bundle of </span><span class="si">{0}</span><span class="s2"> (or no) rings&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rings</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">rings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ring</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rings</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="HexLocation.containsWhichFDMeshPoints"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.containsWhichFDMeshPoints">[docs]</a>    <span class="k">def</span> <span class="nf">containsWhichFDMeshPoints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fullCore</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rectangular</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the difference mesh points contained in a certain location.</span>

<span class="sd">        When building finite different meshes, a lookup table from mesh point to</span>
<span class="sd">        block is required. This method returns a list of x, y indices that</span>
<span class="sd">        the triangle meshes in this location will have in 1/3 symmetric 120 geometry.</span>

<span class="sd">        The mesh indices returned will be 2-d (just x and y) and will start at 1.</span>

<span class="sd">        See Figures 2.4 and 2.6 in the DIF3D manual to understand.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resolution : int, optional</span>
<span class="sd">            How many subdivisions are made in the side of each hex</span>
<span class="sd">                1 means there are 6 triangles.</span>
<span class="sd">                2 means there are 6*4 = 24</span>
<span class="sd">                3 means there are 6*9 = 54</span>
<span class="sd">                4 means there are 6*4*4 = 96, etc.</span>

<span class="sd">        fullCore : bool, optional</span>
<span class="sd">            Makes this relevant for full core with DIFNT (but not DIF3D, which uses &quot;cartesian&quot; triangle meshing)</span>

<span class="sd">        rectangular : bool, optional</span>
<span class="sd">            Use the rectangular indexing domain instead of the parallelogram domain.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        DIF3D full core uses a &quot;rectangular&quot; mesh layout while DIFNT full core uses the rhomboid full core mesh layout</span>
<span class="sd">        so for full core DIFNT, use this. For full core DIF3D, use `rectangular=True`</span>

<span class="sd">        If a hex side is broken into d divisions, then there are</span>
<span class="sd">          * 4d-1 triangles along the center of the hex in the i direction</span>
<span class="sd">          * 2d+1 triangles along the bottom of the hex in the i direction</span>
<span class="sd">          * 2d stacks of triangles in the j-direction.</span>

<span class="sd">        The number of triangles in the i-direction between the first triangle above the centerpoint of two</span>
<span class="sd">        neighboring hexagons is equal to (num center -1)/2 + (num bottom - 1)/2+1, which reduces to 3d.</span>

<span class="sd">        Results should come out left-to-right, top-to-bottom.</span>

<span class="sd">        .. figure:: /.static/triangle_and_hex_mesh.png</span>
<span class="sd">            :target: ../_static/triangle_and_hex_mesh.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :alt: Finite difference mesh layout diagram</span>
<span class="sd">            :width: 50%</span>

<span class="sd">            **Figure 1.** Finite-difference mesh layout of 4 assemblies in locations (1, 1), (2, 1), (2, 2), (2, 6)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fullCore</span><span class="p">:</span>
            <span class="n">symLine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isOnWhichSymmetryLine</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symLine</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">numTriangleStacks</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">resolution</span>
        <span class="n">numAcrossCenter</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">resolution</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">topCenterI</span><span class="p">,</span> <span class="n">topCenterJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getTopCenterIndices</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">rectangular</span><span class="p">)</span>
        <span class="c1"># with this one known, we can find all others</span>

        <span class="n">deltaMeshJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDeltaMeshJ</span><span class="p">(</span><span class="n">numTriangleStacks</span><span class="p">,</span> <span class="n">symLine</span><span class="p">)</span>

        <span class="c1"># Loop through each j row and determine which i indices are present</span>
        <span class="n">indicesHere</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">deltaMeshJ</span><span class="p">):</span>  <span class="c1"># top-to-bottom</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># bottom half of the hexagon</span>
                <span class="k">if</span> <span class="n">symLine</span> <span class="o">==</span> <span class="n">BOUNDARY_120_DEGREES</span> <span class="ow">or</span> <span class="n">symLine</span> <span class="o">==</span> <span class="n">BOUNDARY_CENTER</span><span class="p">:</span>
                    <span class="c1"># is on 120-degree line. only get half the guys.</span>
                    <span class="c1"># 2 level:  num = 1</span>
                    <span class="c1"># 4 levels: num = 1, then 1, 2, 3</span>
                    <span class="c1"># 8 levels: num = 1, then 1, 2, 3, then 1, 2, 3, 4, 5, ...</span>
                    <span class="c1"># so...</span>
                    <span class="c1"># the -1 level will have (numAcrossCenter-1)/2 items (1, 3, 5 for 2, 4, 8 levels)</span>
                    <span class="c1"># the -2 level will have (numAcrossCenter-1)/2-1*2</span>
                    <span class="c1"># the -3 level will have (numAcrossCenter-1)/2-2*2</span>
                    <span class="c1"># the -4 level will have (numAcrossCenter-1)/2-3*2</span>
                    <span class="c1"># in general: the x-level will have</span>
                    <span class="n">numHere</span> <span class="o">=</span> <span class="p">(</span><span class="n">numAcrossCenter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>  <span class="c1"># delta is negative!</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># always starts at one if on this symmetry line.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">numHere</span> <span class="o">=</span> <span class="n">numAcrossCenter</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">topCenterI</span> <span class="o">-</span> <span class="p">(</span><span class="n">numHere</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="ow">not</span> <span class="n">rectangular</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># top half of the hex.</span>
                <span class="k">if</span> <span class="n">symLine</span> <span class="o">==</span> <span class="n">BOUNDARY_120_DEGREES</span> <span class="ow">or</span> <span class="n">symLine</span> <span class="o">==</span> <span class="n">BOUNDARY_CENTER</span><span class="p">:</span>
                    <span class="c1"># special allowance for central positions.)</span>
                    <span class="c1"># one of the three triangles on the top half of the is missing in 120 sym, but it&#39;s there otherwise.</span>
                    <span class="c1"># 120-degree symmetry line.</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="c1"># constant number in this half.</span>
                    <span class="n">numHere</span> <span class="o">=</span> <span class="p">(</span><span class="n">numAcrossCenter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">numHere</span> <span class="o">=</span> <span class="n">numAcrossCenter</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">topCenterI</span> <span class="o">-</span> <span class="p">(</span><span class="n">numHere</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="ow">not</span> <span class="n">rectangular</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numHere</span><span class="p">):</span>
                <span class="n">ii</span><span class="p">,</span> <span class="n">ji</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">topCenterJ</span> <span class="o">+</span> <span class="n">delta</span>
                <span class="n">indicesHere</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ii</span><span class="p">,</span> <span class="n">ji</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">indicesHere</span></div>

<div class="viewcode-block" id="HexLocation._getTopCenterIndices"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation._getTopCenterIndices">[docs]</a>    <span class="k">def</span> <span class="nf">_getTopCenterIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">rectangular</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the mesh indices of the top-center mesh point in this location.&quot;&quot;&quot;</span>
        <span class="c1"># get x, y indices to get away from the ring basis.</span>
        <span class="c1"># indices starts with (0, 0) in the middle, with (r2, p1) -&gt; (1, 0), etc.  (x is on the pos 1 ray)</span>

        <span class="n">numAxialLevels</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">resolution</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rectangular</span><span class="p">:</span>
            <span class="n">topCenterI</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">resolution</span><span class="p">)</span> <span class="o">*</span> <span class="n">xi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 4*d b/c each increase in xi moves you back by numstacks/2</span>
            <span class="n">topCenterI</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">resolution</span><span class="p">)</span> <span class="o">*</span> <span class="n">xi</span> <span class="o">+</span> <span class="p">(</span><span class="n">yi</span> <span class="o">*</span> <span class="n">numAxialLevels</span><span class="p">)</span>
        <span class="n">topCenterJ</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">xi</span> <span class="o">*</span> <span class="n">numAxialLevels</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">numAxialLevels</span> <span class="o">*</span> <span class="n">yi</span>
        <span class="k">return</span> <span class="n">topCenterI</span><span class="p">,</span> <span class="n">topCenterJ</span></div>

<div class="viewcode-block" id="HexLocation._getDeltaMeshJ"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation._getDeltaMeshJ">[docs]</a>    <span class="k">def</span> <span class="nf">_getDeltaMeshJ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numAxialLevels</span><span class="p">,</span> <span class="n">symLine</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the values of the axial coordinates contained in this hex.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">symLine</span> <span class="o">==</span> <span class="n">BOUNDARY_0_DEGREES</span> <span class="ow">or</span> <span class="n">symLine</span> <span class="o">==</span> <span class="n">BOUNDARY_CENTER</span><span class="p">:</span>
            <span class="c1"># this is cut on the bottom. will only have top levels</span>
            <span class="n">deltaAxial</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">numAxialLevels</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deltaAxial</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">numAxialLevels</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">numAxialLevels</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c1"># -1 0 for 2 axial levels.</span>
            <span class="c1"># -2, -1, 0, 1 for 4 axial levels. Perfect since we&#39;re already in top</span>

        <span class="k">return</span> <span class="n">deltaAxial</span></div>

<div class="viewcode-block" id="HexLocation.fromLocator"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.HexLocation.fromLocator">[docs]</a>    <span class="k">def</span> <span class="nf">fromLocator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">HexGrid</span><span class="o">.</span><span class="n">indicesToRingPos</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeLabel</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="CartesianLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.CartesianLocation">[docs]</a><span class="k">class</span> <span class="nc">CartesianLocation</span><span class="p">(</span><span class="n">Location</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Single location in a regular Cartesian grid.</span>

<span class="sd">    This is mutable. It represents a single location at a given time but any instance</span>
<span class="sd">    can be changed to represent any location.</span>

<span class="sd">    For this reason, whenever storing data for a single location, a tuple (i1, i2, ...)</span>
<span class="sd">    should be used instead of the location object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CartesianLocation.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.CartesianLocation.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pitchTuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns x, y coords of the center of this location, assuming square if only xw is given.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pitchTuple</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pitchTuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># useful for relative comparisons.</span>
        <span class="n">xw</span><span class="p">,</span> <span class="n">yw</span> <span class="o">=</span> <span class="n">pitchTuple</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">yw</span><span class="p">:</span>
            <span class="n">yw</span> <span class="o">=</span> <span class="n">xw</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">xw</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yi</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">yw</span>
        <span class="k">if</span> <span class="n">rotationDegreesCCW</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">rotateXY</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>

<div class="viewcode-block" id="CartesianLocation.setIndexNames"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.CartesianLocation.setIndexNames">[docs]</a>    <span class="k">def</span> <span class="nf">setIndexNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a label based on indices.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span></div>

<div class="viewcode-block" id="CartesianLocation.getNumPosInRing"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.CartesianLocation.getNumPosInRing">[docs]</a>    <span class="k">def</span> <span class="nf">getNumPosInRing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ring</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get number of positions in a ring.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ring</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span>

        <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">ring</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span></div>

<div class="viewcode-block" id="CartesianLocation.getNumPositions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.CartesianLocation.getNumPositions">[docs]</a>    <span class="k">def</span> <span class="nf">getNumPositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return The total number of positions in the specified number of rings.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumPosInRing</span><span class="p">(</span><span class="n">ringNum</span><span class="p">)</span> <span class="k">for</span> <span class="n">ringNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rings</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="CartesianLocation.getNumRings"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.CartesianLocation.getNumRings">[docs]</a>    <span class="k">def</span> <span class="nf">getNumRings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nPins</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of rings required to hold a specific number of items, rounding up.&quot;&quot;&quot;</span>
        <span class="n">numPositions</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">nRings</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">numPositions</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumPosInRing</span><span class="p">(</span><span class="n">nRings</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span> <span class="ow">and</span> <span class="n">numPositions</span> <span class="o">&gt;</span> <span class="n">nPins</span><span class="p">:</span>
                <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> does not fit exactly into a cartisian grid of any number of rings. &quot;</span>
                    <span class="s2">&quot;Rounding up to </span><span class="si">{1}</span><span class="s2"> rings which can hold </span><span class="si">{2}</span><span class="s2"> pins)&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nPins</span><span class="p">,</span> <span class="n">nRings</span><span class="p">,</span> <span class="n">numPositions</span><span class="p">),</span>
                    <span class="n">single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Non-exact number of positions in cartesian lattice&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">numPositions</span> <span class="o">&gt;=</span> <span class="n">nPins</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">nRings</span></div></div>


<div class="viewcode-block" id="ThetaRZLocation"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation">[docs]</a><span class="k">class</span> <span class="nc">ThetaRZLocation</span><span class="p">(</span><span class="n">Location</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Location that works in 3-D cylindrical geometry.</span>

<span class="sd">    .. note:: that this location object only works if there is a ThRZmesh</span>
<span class="sd">              object with directions labeled (&#39;R&#39; and &#39;Th&#39;)</span>

<span class="sd">    ThetaRZ location object names represent their discrete position in the mesh</span>
<span class="sd">    object just like in Hexagonal Location Objects. The first two digits represent</span>
<span class="sd">    the azimuthal position, the next three digits represent the radial position and</span>
<span class="sd">    the last digits represents the axial position. For Example, ThetaRZ location</span>
<span class="sd">    A5002B is in the fifth (A5 &gt; 5) azimuthal position, the second radial position (002 &gt; 2) and the</span>
<span class="sd">    second axial (B &gt; 2) position.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">i2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ThRZmesh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; use the general location method plus add mesh and Theta RZ specific labels&quot;&quot;&quot;</span>
        <span class="n">Location</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="o">=</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="o">=</span><span class="n">i2</span><span class="p">,</span> <span class="n">axial</span><span class="o">=</span><span class="n">axial</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ThRZmesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ThRZmesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span> <span class="o">=</span> <span class="n">ThRZmesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setIndexNames</span><span class="p">()</span>

<div class="viewcode-block" id="ThetaRZLocation.getMeshObject"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.getMeshObject">[docs]</a>    <span class="k">def</span> <span class="nf">getMeshObject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span></div>

<div class="viewcode-block" id="ThetaRZLocation.duplicate"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.duplicate">[docs]</a>    <span class="k">def</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">Location</span><span class="o">.</span><span class="n">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">ThRZmesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span>
        <span class="k">return</span> <span class="n">l</span></div>

<div class="viewcode-block" id="ThetaRZLocation.setIndexNames"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.setIndexNames">[docs]</a>    <span class="k">def</span> <span class="nf">setIndexNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set ThetaRZ specific index labels.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2</span></div>

<div class="viewcode-block" id="ThetaRZLocation.niceLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.niceLabel">[docs]</a>    <span class="k">def</span> <span class="nf">niceLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isInCore</span><span class="p">():</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Theta, Radial= </span><span class="si">{0:3d}</span><span class="s2"> </span><span class="si">{1:3d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span></div>

<div class="viewcode-block" id="ThetaRZLocation.fromLabel"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.fromLabel">[docs]</a>    <span class="k">def</span> <span class="nf">fromLabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform lable to ThetaRZ coordinates.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ThetaRZLocation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fromLabel</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setIndexNames</span><span class="p">()</span></div>

<div class="viewcode-block" id="ThetaRZLocation.Rcoords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.Rcoords">[docs]</a>    <span class="k">def</span> <span class="nf">Rcoords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Figures out R coordinates of the center of a Theta-R-Z voxel given theta-R mesh object </span>
<span class="sd">        parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">)):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radialInner</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">radialOuter</span><span class="p">())</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># n = 0</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Error: Radial Index (</span><span class="si">{}</span><span class="s2">) location not INSIDE mesh &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">))</span>
            <span class="n">R</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="ThetaRZLocation.ThRcoords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.ThRcoords">[docs]</a>    <span class="k">def</span> <span class="nf">ThRcoords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Figures out R, theta coordinates of the center of a Theta-R-Z voxel given theta-R mesh </span>
<span class="sd">        object parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rcoords</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">)):</span>
            <span class="n">Th</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaInner</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaOuter</span><span class="p">())</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Error: Azimuthal Index (</span><span class="si">{0}</span><span class="s2">) location not INSIDE mesh &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">))</span>
            <span class="n">Th</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">Th</span><span class="p">,</span> <span class="n">R</span></div>

<div class="viewcode-block" id="ThetaRZLocation.ThRZcoords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.ThRZcoords">[docs]</a>    <span class="k">def</span> <span class="nf">ThRZcoords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Figures out R, theta and Z coordinates of the center of a Theta-R-Z voxel given theta-R </span>
<span class="sd">        mesh object parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Th</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRcoords</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)):</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axial</span><span class="p">))</span>
            <span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Error: Axial Index (</span><span class="si">{0}</span><span class="s2">) location not INSIDE mesh &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axial</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">))</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">Th</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span></div>

<div class="viewcode-block" id="ThetaRZLocation.radialInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.radialInner">[docs]</a>    <span class="k">def</span> <span class="nf">radialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the inner radial position of a Theta-R-Z voxel given a Theta-R mesh </span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">))):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Error: Radial Index (</span><span class="si">{0}</span><span class="s2">) location not INSIDE mesh &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">radial</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">))</span>
            <span class="n">R</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="ThetaRZLocation.radialOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.radialOuter">[docs]</a>    <span class="k">def</span> <span class="nf">radialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the outer radial position of a Theta-R-Z voxel given a Theta-R mesh </span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">))):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Error: Radial Index (</span><span class="si">{0}</span><span class="s2">) location not INSIDE mesh &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">radial</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">))</span>
            <span class="n">R</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="ThetaRZLocation.thetaInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.thetaInner">[docs]</a>    <span class="k">def</span> <span class="nf">thetaInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the inner theta position of a Theta-R-Z voxel given a Theta-R mesh </span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">))):</span>
            <span class="n">Th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Error: Azimuthal Index (</span><span class="si">{0}</span><span class="s2">) location not INSIDE mesh &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">))</span>
            <span class="n">Th</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Th</span></div>

<div class="viewcode-block" id="ThetaRZLocation.axialOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.axialOuter">[docs]</a>    <span class="k">def</span> <span class="nf">axialOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the outer axial position of a Theta-R-Z voxel given a Theta-R mesh </span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">))):</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Z</span></div>

<div class="viewcode-block" id="ThetaRZLocation.axialInner"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.axialInner">[docs]</a>    <span class="k">def</span> <span class="nf">axialInner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the inner axial position of a Theta-R-Z voxel given a Theta-R mesh </span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">))):</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axial</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Z</span></div>

<div class="viewcode-block" id="ThetaRZLocation.thetaOuter"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.thetaOuter">[docs]</a>    <span class="k">def</span> <span class="nf">thetaOuter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the outer radial position of a Theta-R-Z voxel given a Theta-R mesh </span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">))):</span>
            <span class="n">Th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Error: Azimuthal Index (</span><span class="si">{}</span><span class="s2">) location not INSIDE mesh &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">))</span>
            <span class="n">Th</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Th</span></div>

<div class="viewcode-block" id="ThetaRZLocation.coords"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.coords">[docs]</a>    <span class="k">def</span> <span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Figures out x, y coordinates of the center of a Theta-R-Z voxel given theta-R mesh object </span>
<span class="sd">        parameters.</span>

<span class="sd">        Notes</span>
<span class="sd">        ----- </span>
<span class="sd">        p is a dummy variable only there so this method is consistent with the coords method from</span>
<span class="sd">        HexLocation so getDistanceOfLocationToPoint can be defined at the base Location object level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Th</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRcoords</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Th</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Th</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rotationDegreesCCW</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">rotateXY</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotationDegreesCCW</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>

<div class="viewcode-block" id="ThetaRZLocation.getVolume"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.getVolume">[docs]</a>    <span class="k">def</span> <span class="nf">getVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refHeight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axial</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the volume of the radial segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        refHeight : float</span>
<span class="sd">            the height of a radial node in the same units as the</span>
<span class="sd">            locations mesh object</span>

<span class="sd">        axial : int</span>
<span class="sd">            the axial node of the mesh</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        adding an axial node will over write a reference height</span>
<span class="sd">        also, there needs to be a &#39;Z&#39;-labeled mesh in the mesh object for this</span>
<span class="sd">        to define the height, but you knew that already</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axial</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;Z&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getLabelDimensions</span><span class="p">()):</span>
            <span class="n">refHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getDi</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">axial</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">refHeight</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getZArea</span><span class="p">()</span> <span class="o">*</span> <span class="n">refHeight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Cannot calculate volume with height of </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">refHeight</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ThetaRZLocation.getInnerRArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.getInnerRArea">[docs]</a>    <span class="k">def</span> <span class="nf">getInnerRArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refHeight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axial</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the area normal to the r direction on the inside of the radial segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        refHeight : float</span>
<span class="sd">            the height of a radial node in the same units as the</span>
<span class="sd">            locations mesh object</span>

<span class="sd">        axial : int</span>
<span class="sd">            the axial node of the mesh</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        adding an axial node will over write a reference height</span>
<span class="sd">        also, there needs to be a &#39;Z&#39;-labeled mesh in the mesh object for this</span>
<span class="sd">        to define the height, but you knew that already</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axial</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;Z&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getLabelDimensions</span><span class="p">()):</span>
            <span class="n">refHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getDi</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">axial</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">refHeight</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaOuter</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaInner</span><span class="p">())</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radialInner</span><span class="p">()</span> <span class="o">*</span> <span class="n">refHeight</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="ThetaRZLocation.getOuterRArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.getOuterRArea">[docs]</a>    <span class="k">def</span> <span class="nf">getOuterRArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refHeight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axial</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">axial</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;Z&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getLabelDimensions</span><span class="p">()):</span>
            <span class="n">refHeight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ThRZmesh</span><span class="o">.</span><span class="n">getDi</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">axial</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">refHeight</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaOuter</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaInner</span><span class="p">())</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radialOuter</span><span class="p">()</span> <span class="o">*</span> <span class="n">refHeight</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="ThetaRZLocation.getZArea"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.ThetaRZLocation.getZArea">[docs]</a>    <span class="k">def</span> <span class="nf">getZArea</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radialOuter</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">radialInner</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">/</span> <span class="mf">2.0</span>
            <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thetaOuter</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">thetaInner</span><span class="p">())</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="Mesh"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh">[docs]</a><span class="k">class</span> <span class="nc">Mesh</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object helps ARMI define and pass structured orthogonal meshes (X, Y, Z)</span>
<span class="sd">    or (R, Z, Th). When going from X, Y, Z on orthogonal, but non-regular meshes</span>
<span class="sd">    (the pitch isn&#39;t constant) you need to know what the mesh is in order to</span>
<span class="sd">    determine the cartesian coordinates</span>
<span class="sd">    also, you&#39;re not limited to 3 dimensions so this mesh</span>

<span class="sd">    Rebase meshes such that index 1 is the first index rather than 0</span>
<span class="sd">    This is accomplished by setting 0 as the first index</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is intended to be replaced with the newer grids.ThetaRZGrid functionality.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initilizes mesh object.</span>

<span class="sd">        self.di dictionary indexed by direction label (&#39;X&#39;, &#39;Y&#39;, etc) of differences</span>
<span class="sd">        self.i dictionary indexed by direction label(&#39;X&#39;, &#39;Y&#39;, etc) of positions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set of lists of nodal differences</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">di</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># self of upper boudns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Mesh.getNumDimensions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getNumDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">getNumDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of dimensions in the mesh.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="Mesh.getLabelDimensions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getLabelDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">getLabelDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the labels of the dimensions in the mesh.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="Mesh.getDiLength"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getDiLength">[docs]</a>    <span class="k">def</span> <span class="nf">getDiLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Rreturns the difference in lengths in the mesh in the direction labeled.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label: string</span>
<span class="sd">            The label of the direction (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">])</span></div>

<div class="viewcode-block" id="Mesh.getDi"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getDi">[docs]</a>    <span class="k">def</span> <span class="nf">getDi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the n-th difference in lengths in the mesh in the direction labeled.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n: integer</span>
<span class="sd">            The index of position with in mesh structure.</span>
<span class="sd">            </span>
<span class="sd">        label: string</span>
<span class="sd">            The label of the direction (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="Mesh.getUpper"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getUpper">[docs]</a>    <span class="k">def</span> <span class="nf">getUpper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the outer position of the n-th element in the mesh in the direction labeled.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n: integer </span>
<span class="sd">            The index of position with in mesh structure</span>
<span class="sd">            </span>
<span class="sd">        label: string</span>
<span class="sd">            The label of the direction (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="Mesh.getUpperLowerFromPosition"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getUpperLowerFromPosition">[docs]</a>    <span class="k">def</span> <span class="nf">getUpperLowerFromPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the upper and lower interface indexes for a given position in a given direction.</span>
<span class="sd">        </span>
<span class="sd">        p is the position in the direction labeled label is the string name of the target </span>
<span class="sd">        directions label.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPositions</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># print &quot;Warning: position %1.5E is less than lowest interface %1.5E&quot; % (p, self.i[label][0])</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sigma</span><span class="p">)):</span>
            <span class="c1"># print &quot;Warning: position %1.5E is greater than the greatest interface %1.5E&quot; % (p, self.i[label][-1])</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigma</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Mesh.isPositionInMesh"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.isPositionInMesh">[docs]</a>    <span class="k">def</span> <span class="nf">isPositionInMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>

        <span class="n">pI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClosestUpperFromPosition</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">pI</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sigma</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Mesh.getClosestUpperFromPosition"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getClosestUpperFromPosition">[docs]</a>    <span class="k">def</span> <span class="nf">getClosestUpperFromPosition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the closest position in the mesh in the direction labeled, label.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            i = 0</span>
<span class="sd">            self.i[label][i]-p</span>
<span class="sd">            self.di[label][i]</span>
<span class="sd">            len(self.i[label])</span>
<span class="sd">            while math.fabs(self.i[label][i]-p) &gt; self.di[label][i] and i &lt; len(self.i[label]):</span>
<span class="sd">                i += 1</span>
<span class="sd">            if  math.fabs(p - self.i[label][i]) &lt; (self.di[label][i]/2):</span>
<span class="sd">                # closer to lower bounds</span>
<span class="sd">                # or looped through the mesh without finding a closest match</span>
<span class="sd">                if i == (len(self.i[label])-1) or math.fabs(p - self.i[label][i]) &lt; math.fabs(p - self.i[label][i+1]):</span>
<span class="sd">                    return i</span>
<span class="sd">                else:</span>
<span class="sd">                    return (i + 1)</span>
<span class="sd">            else:</span>
<span class="sd">                return i + 1</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">p</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Mesh.addFromDeltas"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.addFromDeltas">[docs]</a>    <span class="k">def</span> <span class="nf">addFromDeltas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deltas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define mesh(s) in the labeled direction(s).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deltas: a list, either a list of lists or a single list of mesh differences (like heights in an assembly)</span>
<span class="sd">        labels: a string or list of strings of the labels (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;) of directions</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you want to define multiple directions in one command then deltas should be a </span>
<span class="sd">        list of lists, and there should be a label for every direction and the order of labels and </span>
<span class="sd">        deltas should be lined up.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ensure there&#39;s a label for each direction</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltas</span><span class="p">):</span>
                <span class="c1"># labels will be made up</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltas</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span>
                <span class="p">):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># there is a label for each direction</span>
                <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">deltas</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__iter___&quot;</span><span class="p">):</span>
                <span class="c1"># there are multiple directions that need labels</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltas</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">deltas</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="c1"># there are multiple lists</span>
            <span class="k">for</span> <span class="n">delta</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addOneDirectionFromDeltas</span><span class="p">(</span><span class="n">deltas</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addOneDirectionFromDeltas</span><span class="p">(</span><span class="n">deltas</span><span class="o">=</span><span class="n">deltas</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.addFromPositions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.addFromPositions">[docs]</a>    <span class="k">def</span> <span class="nf">addFromPositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Define mesh(s) in the labeled direction(s).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions: list </span>
<span class="sd">            Either a list of lists or a single list of mesh positions</span>
<span class="sd">        </span>
<span class="sd">        labels: a string or list of strings of the labels (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;) of directions</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you want to define multiple directions in one command then positions should be a list of lists,</span>
<span class="sd">        and there should be a label for every direction and the order of labels and positions should be lined up</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ensure there&#39;s a label for each direction</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
                <span class="c1"># labels will be made up</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span>
                <span class="p">):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># there is a label for each direction</span>
                <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># there are multiple directions that need labels</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># there are multiple lists</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">position</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addOneDirectionFromPositions</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addOneDirectionFromPositions</span><span class="p">(</span><span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.addFromRegularIntervals"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.addFromRegularIntervals">[docs]</a>    <span class="k">def</span> <span class="nf">addFromRegularIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dIs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines regular intervals mesh(s) in the labeled direction(s).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dIs: a float or a list of floats of the regular difference (think pitch)</span>
<span class="sd">        labels: a string or list of strings of the labels (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;) of directions</span>
<span class="sd">        Ns: a float or a list of floats of the number of elements in the mesh</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If you want to define multiple directions in one command then dIs and Ns should be a list,</span>
<span class="sd">        and there should be a label for every direction and the order of labels, dIs and Ns should be lined up</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ensure there&#39;s a label for each direction</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dIs</span><span class="p">):</span>
                <span class="c1"># labels will be made up</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">dIs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># there is a label for each direction</span>
                <span class="k">pass</span>

        <span class="k">elif</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dIs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="c1"># there are multiple directions that need labels</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">dIs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dI</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dIs</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addOneDirectionFromRegInterval</span><span class="p">(</span><span class="n">dI</span><span class="o">=</span><span class="n">dI</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.addFromMaximums"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.addFromMaximums">[docs]</a>    <span class="k">def</span> <span class="nf">addFromMaximums</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Maxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines regular intervals mesh(s) in the labeled direction(s) from a maximum position and</span>
<span class="sd">        number of nodes.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Maxs: a float or a list of floats of the regular difference (think pitch)</span>
<span class="sd">        labels: a string or list of strings of the labels (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;) of directions</span>

<span class="sd">        (note) if you want to define multiple directions in one command then deltas should be a list of lists,</span>
<span class="sd">        and there should be a label for every direction and the order of labels and deltas should be lined up</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Maxs</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="n">dIs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="nb">max</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Maxs</span><span class="p">,</span> <span class="n">Ns</span><span class="p">):</span>
                <span class="n">dIs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addFromRegularIntervals</span><span class="p">(</span><span class="n">dIs</span><span class="o">=</span><span class="n">dIs</span><span class="p">,</span> <span class="n">Ns</span><span class="o">=</span><span class="n">Ns</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addRegDirectionFromMax</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="n">Maxs</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">Ns</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.addOneDirectionFromDeltas"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.addOneDirectionFromDeltas">[docs]</a>    <span class="k">def</span> <span class="nf">addOneDirectionFromDeltas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deltas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines regular intervals mesh in a single direction.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deltas: a list of mesh differences (like heights in an assembly)</span>
<span class="sd">        label: a string of the labels (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;) of directions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># add a direction based on the position differences</span>
        <span class="c1"># assume deltas is 1-D list</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">dl</span> <span class="ow">in</span> <span class="n">deltas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>
            <span class="n">L</span> <span class="o">+=</span> <span class="n">dl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">checkMesh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.addOneDirectionFromPositions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.addOneDirectionFromPositions">[docs]</a>    <span class="k">def</span> <span class="nf">addOneDirectionFromPositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines regular intervals mesh in a single direction.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions: a list of mesh positions</span>
<span class="sd">        label: a string of the labels (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;) of directions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add a direction based on the position differences</span>
        <span class="c1"># assume deltas is 1-D list</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="n">dl</span> <span class="o">=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">l</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkMesh</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.addOneDirectionFromRegInterval"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.addOneDirectionFromRegInterval">[docs]</a>    <span class="k">def</span> <span class="nf">addOneDirectionFromRegInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dI</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines regular intervals mesh in a single direction.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dI: the standard regular interval</span>
<span class="sd">        N: the number of elements in a mesh</span>
<span class="sd">        label: a string of the labels (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;) of directions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;Direction</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">L</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">L</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">L</span> <span class="o">+=</span> <span class="n">dI</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dI</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.addRegDirectionFromMax"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.addRegDirectionFromMax">[docs]</a>    <span class="k">def</span> <span class="nf">addRegDirectionFromMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines regular intervals mesh in a single direction based on the maximum position.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Maximum: the maximum position on a mesh (think height of an assembly)</span>
<span class="sd">        N: the number of elements in a mesh</span>
<span class="sd">        label: a string of the labels (i.e &#39;X&#39;, &#39;Y&#39;, &#39;Theta&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;E&#39;) of directions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dI</span> <span class="o">=</span> <span class="n">L</span> <span class="o">/</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addOneDirectionFromRegInterval</span><span class="p">(</span><span class="n">dI</span><span class="o">=</span><span class="n">dI</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.checkMesh"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.checkMesh">[docs]</a>    <span class="k">def</span> <span class="nf">checkMesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This ensures that 0 is included in the mesh.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        ----- </span>
<span class="sd">        If the mesh includes both negative and positive values it doesn&#39;t</span>
<span class="sd">        need to have a 0 position, otherwise its inferred that you need a 0</span>
<span class="sd">        position and this helps you generated it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="c1"># the mesh is entirely on one side of 0</span>
            <span class="c1"># these meshes should include 0 so that the first index defines the upper bound and index - 1 defines the lower bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">appendUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.setIInternal"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.setIInternal">[docs]</a>    <span class="k">def</span> <span class="nf">setIInternal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If you define a meshes set of differences this updates the positions.&quot;&quot;&quot;</span>
        <span class="c1"># if the di vectors are defined this method populates the upper limit vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
                <span class="n">L</span> <span class="o">+=</span> <span class="n">l</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.setDiInternal"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.setDiInternal">[docs]</a>    <span class="k">def</span> <span class="nf">setDiInternal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If you define a meshes set of positions this updates the differences.&quot;&quot;&quot;</span>
        <span class="c1"># if the di vectors are defined this method populates the upper limit vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">di</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
                <span class="n">dl</span> <span class="o">=</span> <span class="n">L</span> <span class="o">-</span> <span class="n">l</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">L</span></div>

<div class="viewcode-block" id="Mesh.appendUpper"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.appendUpper">[docs]</a>    <span class="k">def</span> <span class="nf">appendUpper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method adds an additional position in the I vector to a given direction.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        If you are defining a grid you can define an additional stack of</span>
<span class="sd">        elements with a verticle mesh that doesn&#39;t align with the initial mesh and</span>
<span class="sd">        use this method to fill in the gaps and update the differences.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check to see if direction is defined</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>

            <span class="c1"># determine where the position p fits into the grid</span>
            <span class="n">L</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getUpperLowerFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># p is below the lowest position in the mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">)]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">)]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

            <span class="k">elif</span> <span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># p is above hightest position in the mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># position p is between positions (L, U) in the direction</span>
                <span class="c1"># update the differences</span>
                <span class="c1"># self.di[label] = self.di[label][:L] + [(p - self.i[label][L]), (self.i[label][U] - p)] + self.di[label][U:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">][:</span><span class="n">U</span><span class="p">]</span>
                    <span class="o">+</span> <span class="p">[(</span><span class="n">p</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">L</span><span class="p">]),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">U</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">U</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
                <span class="p">)</span>
                <span class="c1"># redefine the mesh with new position</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][:</span><span class="n">U</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="n">U</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># p is already in the mesh, so you&#39;re done</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="Mesh.appendFromBounds"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.appendFromBounds">[docs]</a>    <span class="k">def</span> <span class="nf">appendFromBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds mesh points from bounds (upper and lower) and number of cells between the bounds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : string</span>
<span class="sd">            direction label</span>

<span class="sd">        p1: float</span>
<span class="sd">            inner position</span>

<span class="sd">        p2: float</span>
<span class="sd">            outer position</span>

<span class="sd">        n: int</span>
<span class="sd">            number of cells between the bounds</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        armi.reactor.reactors.findAllAziMeshPoints</span>
<span class="sd">        armi.reactor.reactors.findAllRadMeshPoints</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">di</span> <span class="o">=</span> <span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">p1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">appendUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">+=</span> <span class="n">di</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">appendUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">appendUpper</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Mesh.getPositions"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getPositions">[docs]</a>    <span class="k">def</span> <span class="nf">getPositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][:]</span></div>

<div class="viewcode-block" id="Mesh.getDifferences"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getDifferences">[docs]</a>    <span class="k">def</span> <span class="nf">getDifferences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">di</span><span class="p">[</span><span class="n">label</span><span class="p">][:]</span></div>

<div class="viewcode-block" id="Mesh.getMaximum"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getMaximum">[docs]</a>    <span class="k">def</span> <span class="nf">getMaximum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Mesh.getThRLocations"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getThRLocations">[docs]</a>    <span class="k">def</span> <span class="nf">getThRLocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns a list of location objects for each node bound by the positions in the </span>
<span class="sd">        mesh.</span>
<span class="sd">        </span>
<span class="sd">                  ----------- I[&#39;R&#39;][r+1]</span>
<span class="sd">                  |          |</span>
<span class="sd">                  |          |</span>
<span class="sd">        I[&#39;Th&#39;][t]| Location | I[&#39;Theta&#39;][t+1]</span>
<span class="sd">                  |[t+1][r+1]|</span>
<span class="sd">                  |          |</span>
<span class="sd">                  ------------I[&#39;R&#39;][r]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check directions for see there is an R and Th direction</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkThR</span><span class="p">():</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Warning both R and Th are not present in mesh object with dimensions:&quot;</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getLabelDimensions</span><span class="p">())</span>

        <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDiLength</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">radial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDiLength</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">)):</span>
                <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ThetaRZLocation</span><span class="p">(</span><span class="n">i1</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">i2</span><span class="o">=</span><span class="n">radial</span><span class="p">,</span> <span class="n">ThRZmesh</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">locations</span></div>

<div class="viewcode-block" id="Mesh.getThRZLocationsFromBounds"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Mesh.getThRZLocationsFromBounds">[docs]</a>    <span class="k">def</span> <span class="nf">getThRZLocationsFromBounds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">r1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">r2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">t1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">t2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">z1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">z2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">units</span><span class="o">=</span><span class="s2">&quot;Radians&quot;</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns a list of locations bounded by defined surfaces.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r1 : float</span>
<span class="sd">            inner radius of control volume</span>
<span class="sd">        r2 : float</span>
<span class="sd">            outer radius of control volume</span>
<span class="sd">        t1 : float</span>
<span class="sd">            inner azimuthal location of control volume</span>
<span class="sd">        t2 : float</span>
<span class="sd">            inner azimuthal of control volume</span>
<span class="sd">        z1 : float</span>
<span class="sd">            inner axial location of control volume</span>
<span class="sd">        z2 : float</span>
<span class="sd">            inner axial of control volume</span>
<span class="sd">        units: string</span>
<span class="sd">            flag to use either radians (default) or degrees</span>
<span class="sd">        sigma: float</span>
<span class="sd">            acceptable relative error (i.e. if one of the positions in the mesh are within this</span>
<span class="sd">            error it&#39;ll act the same if it matches a position in the mesh)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">units</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;degrees&quot;</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">t1</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">t2</span>

        <span class="c1"># check that mesh includes Th and R</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkThR</span><span class="p">():</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Warning both R and Th are not present in mesh object with dimensions:&quot;</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getLabelDimensions</span><span class="p">())</span>

        <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># check to see if positions are in mesh</span>
        <span class="c1"># if r1 in self.getPositions(&#39;R&#39;) and r2 in self.getPositions(&#39;R&#39;) and t1 in self.getPositions(&#39;Th&#39;) and t2 in self.getPositions(&#39;Th&#39;) and z1 in self.getPositions(&#39;Z&#39;) and z2 in self.getPositions(&#39;Z&#39;):</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isPositionInMesh</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPositionInMesh</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">r2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPositionInMesh</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">t1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPositionInMesh</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">t2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPositionInMesh</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">z1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPositionInMesh</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">z2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="p">):</span>

            <span class="c1">#&#39;yay! the bounds are in the mesh&#39;</span>

            <span class="n">rIndexLower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClosestUpperFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">)</span>
            <span class="n">rIndexUpper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClosestUpperFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">r2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">)</span>
            <span class="n">thIndexLower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClosestUpperFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">t1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">)</span>
            <span class="n">thIndexUpper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClosestUpperFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">t2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">)</span>
            <span class="n">zIndexLower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClosestUpperFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">z1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>
            <span class="n">zIndexUpper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getClosestUpperFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">z2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Warning not all positions are in the Th-R mesh, the locations are the closest&quot;</span>
            <span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">)</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getUpperLowerFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">rIndexLower</span> <span class="o">=</span> <span class="n">i1</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getUpperLowerFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">r2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">rIndexUpper</span> <span class="o">=</span> <span class="n">i2</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getUpperLowerFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">t1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">thIndexLower</span> <span class="o">=</span> <span class="n">i1</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getUpperLowerFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">t2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Th&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">thIndexUpper</span> <span class="o">=</span> <span class="n">i2</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getUpperLowerFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">z1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">zIndexLower</span> <span class="o">=</span> <span class="n">i1</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getUpperLowerFromPosition</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">z2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">zIndexUpper</span> <span class="o">=</span> <span class="n">i2</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">radial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rIndexLower</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rIndexUpper</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">thIndexLower</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">thIndexUpper</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">zIndexLower</span><span class="p">,</span> <span class="n">zIndexUpper</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">ThetaRZLocation</span><span class="p">(</span><span class="n">i1</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">i2</span><span class="o">=</span><span class="n">radial</span><span class="p">,</span> <span class="n">ThRZmesh</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">locations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">setAxial</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                        <span class="n">locations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">makeLabel</span><span class="p">()</span>

        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># got a NoneType instead of an integer ... so fail by returning whatever we have for integer</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">locations</span></div></div>


<div class="viewcode-block" id="Area"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Area">[docs]</a><span class="k">class</span> <span class="nc">Area</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Area.sense"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Area.sense">[docs]</a>    <span class="k">def</span> <span class="nf">sense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesianTuple</span><span class="p">):</span>

        <span class="n">S</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">line</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">*</span> <span class="n">line</span><span class="o">.</span><span class="n">sense</span><span class="p">(</span><span class="n">cartesianTuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">S</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">S</span></div></div>


<div class="viewcode-block" id="Line"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Line">[docs]</a><span class="k">class</span> <span class="nc">Line</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c1"># a quadradic equation that represents a line in 2D cartesian space</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># a reference point on this line</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;y1&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;y2&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="c1"># polynomical coefficients that define this line</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cardinalDirection</span> <span class="o">=</span> <span class="s2">&quot;y&quot;</span>
        <span class="c1"># a flag</span>

<div class="viewcode-block" id="Line.sense"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Line.sense">[docs]</a>    <span class="k">def</span> <span class="nf">sense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesian</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the &#39;sense&#39; of a cartesian point (x, y) with</span>
<span class="sd">        respect to the line. The sense of a point is useful in establishing</span>
<span class="sd">        whethor or not a point is within a defined area or volume.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cartesian: tuple-like of float-like</span>
<span class="sd">            the first element is the x-coordinate and the second element is the y-coordinate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sense: float</span>
<span class="sd">            this can be negative (inside) positive (outside) or zero (actually on the line,</span>
<span class="sd">            the cartesian point satisfies the polynomial equation)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">cartesian</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x2&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">cartesian</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">cartesian</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y2&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">cartesian</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="Line.getY"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Line.getY">[docs]</a>    <span class="k">def</span> <span class="nf">getY</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the a list of y-values that satisfy the polynomial equation of</span>
<span class="sd">        this line by using the quadratic formula.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: float-like</span>
<span class="sd">            x-coordinate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sense: [y1, (y2)]</span>
<span class="sd">            The solutions to the polynomial equation, this method returns [None]</span>
<span class="sd">            if there are no real intercepts and &#39;inf&#39; if there are this is a</span>
<span class="sd">            constant value line (c=0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y2&quot;</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y1&quot;</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x2&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mf">2.0</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="Line.getX"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Line.getX">[docs]</a>    <span class="k">def</span> <span class="nf">getX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the a list of x-values that satisfy the polynomial equation of</span>
<span class="sd">        this line by using the quadratic formula.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y: float-like</span>
<span class="sd">            y-coordinate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sense: [x1, (x2)]</span>
<span class="sd">            The solutions to the polynomial equation, this method returns [None]</span>
<span class="sd">            if there are no real intercepts and &#39;inf&#39; if there are this is a</span>
<span class="sd">            constant value line (c=0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x2&quot;</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x1&quot;</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y2&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span> <span class="o">**</span> <span class="mf">2.0</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="Line.quadratic"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Line.quadratic">[docs]</a>    <span class="k">def</span> <span class="nf">quadratic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method solves the quadratic equation (a*x**2 + b*x + c = 0).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b, c : float-like</span>
<span class="sd">            coefficients in a quadratic equation: (a*x**2 + b*x + c = 0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        [x1, (x2)]: list of floats</span>
<span class="sd">            Solutions to the polynomial.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;inf&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># form b*y + c = 0</span>
            <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">c</span> <span class="o">/</span> <span class="n">b</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># standard quadradic formula</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">),</span>
                <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">b</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">a</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only interested in real solutions, so toss out imaginary ones</span>
            <span class="n">runLog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;warning no intercepts&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="Line.arcLength"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.Line.arcLength">[docs]</a>    <span class="k">def</span> <span class="nf">arcLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>

        <span class="c1"># numerically integrate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinalDirection</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="c1"># transform coordinates from y-based to x-based</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinalDirection</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">dx</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="o">+</span> <span class="p">(</span>
                        <span class="n">dx</span>
                        <span class="o">*</span> <span class="p">(</span>
                            <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x2&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>
                            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x1&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y1&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="o">**</span> <span class="mi">2</span>
                <span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">dy</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="o">+</span> <span class="p">(</span>
                        <span class="n">dy</span>
                        <span class="o">*</span> <span class="p">(</span>
                            <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y2&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span>
                            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;y1&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">[</span><span class="s2">&quot;x1&quot;</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="o">**</span> <span class="mi">2</span>
                <span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">s</span></div></div>


<div class="viewcode-block" id="locationFactory"><a class="viewcode-back" href="../../../.apidocs/armi.reactor.locations.html#armi.reactor.assemblies.locationFactory">[docs]</a><span class="k">def</span> <span class="nf">locationFactory</span><span class="p">(</span><span class="n">geomType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Choose a location class.&quot;&quot;&quot;</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">CARTESIAN</span><span class="p">:</span> <span class="n">CartesianLocation</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">RZT</span><span class="p">:</span> <span class="n">ThetaRZLocation</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">HEX</span><span class="p">:</span> <span class="n">HexLocation</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">DODECAGON</span><span class="p">:</span> <span class="n">HexLocation</span><span class="p">,</span>  <span class="c1"># yes, it&#39;s same as hex. That&#39;s what we want.</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">RZ</span><span class="p">:</span> <span class="n">ThetaRZLocation</span><span class="p">,</span>
        <span class="c1"># database names...</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">REC_PRISM</span><span class="p">:</span> <span class="n">CartesianLocation</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">HEX_PRISM</span><span class="p">:</span> <span class="n">HexLocation</span><span class="p">,</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">ANNULUS_SECTOR_PRISM</span><span class="p">:</span> <span class="n">ThetaRZLocation</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">locClass</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">geomType</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">locClass</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unsupported geometry option: &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">geomType</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">locClass</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2009-2020, TerraPower, LLC
      <span class="lastupdated">
        Last updated on 2020-09-29.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>